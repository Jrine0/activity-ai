<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Parking Spot Finder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .simulator-container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .header h2 {
            font-size: 2.5rem;
            color: #4CC9F0;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .header p {
            color: #8BA8B8;
        }

        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            background: rgba(0, 0, 0, 0.2);
            padding: 1rem;
            border-radius: 12px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 201, 240, 0.3);
        }

        .btn-primary {
            background-color: #4CC9F0;
            color: black;
        }

        .btn-action {
            background-color: #F72585;
            color: white;
        }

        .btn-tool {
            background-color: #3A0CA3;
            color: white;
            opacity: 0.7;
        }

        .btn-tool.active {
            opacity: 1;
            border: 2px solid #4CC9F0;
        }

        select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 2px solid #4CC9F0;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 14px;
        }

        .legend {
            display: flex;
            gap: 2rem;
            margin-bottom: 1rem;
            color: #8BA8B8;
            font-size: 0.9rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-box {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .canvas-area {
            width: 100%;
            height: 600px;
            background: #111;
            border-radius: 12px;
            overflow: hidden;
            border: 3px solid #4CC9F0;
            box-shadow: 0 10px 40px rgba(76, 201, 240, 0.2);
            position: relative;
        }

        canvas {
            display: block;
        }

        /* Checkbox styling */
        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        input[type="checkbox"] {
            accent-color: #4CC9F0;
            width: 18px;
            height: 18px;
        }
    </style>
</head>

<body>
    <div class="simulator-container">
        <div class="header">
            <h2>üÖøÔ∏è Smart Parking Spot Finder</h2>
            <p>Find the optimal parking spot using advanced pathfinding algorithms</p>
        </div>

        <div class="controls">
            <select id="algorithm">
                <option value="bfs">Breadth-First Search (BFS)</option>
                <option value="astar">A* Search (Heuristic)</option>
            </select>

            <label class="checkbox-wrapper">
                <input type="checkbox" id="handicap">
                <span>‚ôø Handicap Permit</span>
            </label>

            <div style="width: 1px; height: 30px; background: rgba(255,255,255,0.2); margin: 0 10px;"></div>

            <button class="btn btn-primary" onclick="generateParkingLot()">
                üèóÔ∏è Generate Lot
            </button>
            <button class="btn btn-action" onclick="solveParking()">
                üöó Find Spot
            </button>
            <button class="btn btn-tool" onclick="clearGrid()" style="background-color: #ff4444;">
                üóëÔ∏è Clear
            </button>
        </div>

        <div class="controls" style="background: rgba(0,0,0,0.1); padding: 0.5rem; margin-top: -1rem;">
            <span style="margin-right: 10px; font-size: 0.9rem; color: #aaa;">Manual Tools:</span>
            <button class="btn btn-tool active" onclick="setTool('wall', this)">üß± Wall</button>
            <button class="btn btn-tool" onclick="setTool('entry', this)">üö© Entry</button>
            <button class="btn btn-tool" onclick="setTool('spot', this)">üü© Free</button>
            <button class="btn btn-tool" onclick="setTool('occupied', this)">üü• Occupied</button>
            <button class="btn btn-tool" onclick="setTool('reserved', this)">‚ôø Reserved</button>
            <button class="btn btn-tool" onclick="setTool('eraser', this)">üßΩ Eraser</button>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-box" style="background: #333; border: 1px solid #555;"></div>
                <span>Driveway</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #2a2a2a; border: 1px dashed white;"></div>
                <span>Free Spot</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #ff4444;"></div>
                <span>Occupied</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #0066cc;"></div>
                <span>Reserved</span>
            </div>
        </div>

        <div class="canvas-area" id="canvas-container">
            <canvas id="simCanvas"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        let cellSize = 25;
        let cols, rows;
        let grid = [];
        // 0: driveway, 1: wall, 2: free spot, 3: occupied, 4: reserved
        let startNode = null;
        let currentTool = 'wall';
        let isDrawing = false;
        let path = [];

        /* ----------------------- INITIALIZATION ----------------------- */
        setTimeout(() => {
            resizeCanvas();
            generateParkingLot();
        }, 100);

        window.addEventListener('resize', () => {
            resizeCanvas();
            draw();
        });

        function resizeCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            cols = Math.floor(canvas.width / cellSize);
            rows = Math.floor(canvas.height / cellSize);
            if (grid.length === 0) initGrid();
        }

        function initGrid() {
            grid = new Array(cols).fill(0).map(() => new Array(rows).fill(0));
        }

        /* ----------------------- GENERATION ----------------------- */
        async function generateParkingLot() {
            try {
                const response = await fetch('/api/generate_parking/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: JSON.stringify({ rows: rows, cols: cols })
                });

                const result = await response.json();
                if (result.error) {
                    alert(result.error);
                    return;
                }

                grid = result.grid;
                startNode = result.start;
                path = [];
                draw();

            } catch (error) {
                console.error('Error:', error);
            }
        }

        /* ----------------------- DRAWING ----------------------- */
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background (Asphalt)
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Grid Lines (Subtle)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= cols; i++) {
                ctx.beginPath(); ctx.moveTo(i * cellSize, 0); ctx.lineTo(i * cellSize, rows * cellSize); ctx.stroke();
            }
            for (let j = 0; j <= rows; j++) {
                ctx.beginPath(); ctx.moveTo(0, j * cellSize); ctx.lineTo(cols * cellSize, j * cellSize); ctx.stroke();
            }

            // Draw Cells
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const val = grid[i][j];
                    const x = i * cellSize;
                    const y = j * cellSize;

                    if (val === 1) { // Wall
                        ctx.fillStyle = '#111';
                        ctx.fillRect(x, y, cellSize, cellSize);
                        ctx.strokeStyle = '#444';
                        ctx.strokeRect(x, y, cellSize, cellSize);
                    }
                    else if (val === 0) { // Driveway
                        // Just asphalt, maybe lane markings?
                        ctx.fillStyle = '#333';
                        ctx.fillRect(x, y, cellSize, cellSize);
                    }
                    else if (val === 2 || val === 3 || val === 4) { // Spots
                        // Draw Parking Spot Lines
                        ctx.fillStyle = val === 4 ? 'rgba(0, 100, 255, 0.2)' : '#2a2a2a';
                        ctx.fillRect(x + 2, y + 2, cellSize - 4, cellSize - 4);

                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        // Draw U-shape or box for spot
                        ctx.strokeRect(x + 2, y + 2, cellSize - 4, cellSize - 4);

                        if (val === 3) { // Occupied (Car)
                            drawCar(x, y, '#ff4444');
                        } else if (val === 4) { // Reserved
                            // Draw Wheelchair symbol (simplified)
                            ctx.fillStyle = '#4CC9F0';
                            ctx.font = '14px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('‚ôø', x + cellSize / 2, y + cellSize / 2);
                        }
                    }
                }
            }

            // Draw Entry Car
            if (startNode) {
                drawCar(startNode.x * cellSize, startNode.y * cellSize, '#FFD700', true);
            }

            // Draw Path
            if (path.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = '#00FF00';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00FF00';

                ctx.moveTo(path[0][0] * cellSize + cellSize / 2, path[0][1] * cellSize + cellSize / 2);
                for (let k = 1; k < path.length; k++) {
                    ctx.lineTo(path[k][0] * cellSize + cellSize / 2, path[k][1] * cellSize + cellSize / 2);
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        }

        function drawCar(x, y, color, isPlayer = false) {
            const padding = 4;
            const w = cellSize - padding * 2;
            const h = cellSize - padding * 2;

            ctx.fillStyle = color;

            // Rounded rect for car
            ctx.beginPath();
            ctx.roundRect(x + padding, y + padding, w, h, 4);
            ctx.fill();

            // Windshield
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(x + padding + 2, y + padding + 4, w - 4, h / 3);

            if (isPlayer) {
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = 'black';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('YOU', x + cellSize / 2, y + cellSize / 2);
            }
        }

        /* ----------------------- INTERACTION ----------------------- */
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: Math.floor((evt.clientX - rect.left) / cellSize),
                y: Math.floor((evt.clientY - rect.top) / cellSize)
            };
        }

        function setTool(tool, btn) {
            currentTool = tool;
            // Update UI
            document.querySelectorAll('.btn-tool').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
        }

        function clearGrid() {
            grid = grid.map(col => col.map(() => 0));
            startNode = null;
            path = [];
            draw();
        }

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            handleInput(e);
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDrawing) handleInput(e);
        });

        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false);

        function handleInput(e) {
            const pos = getMousePos(e);
            if (pos.x < 0 || pos.x >= cols || pos.y < 0 || pos.y >= rows) return;

            if (currentTool === 'wall') grid[pos.x][pos.y] = 1;
            else if (currentTool === 'spot') grid[pos.x][pos.y] = 2;
            else if (currentTool === 'occupied') grid[pos.x][pos.y] = 3;
            else if (currentTool === 'reserved') grid[pos.x][pos.y] = 4;
            else if (currentTool === 'eraser') {
                grid[pos.x][pos.y] = 0;
                if (startNode && startNode.x === pos.x && startNode.y === pos.y) startNode = null;
            } else if (currentTool === 'entry') {
                startNode = pos;
                grid[pos.x][pos.y] = 0;
            }
            draw();
        }

        /* ----------------------- SOLVER ----------------------- */
        async function solveParking() {
            if (!startNode) {
                alert('Please set an Entry point (Car) or Generate a Lot first.');
                return;
            }

            const algorithm = document.getElementById('algorithm').value;
            const handicap = document.getElementById('handicap').checked;

            const data = {
                grid: grid,
                start: startNode,
                algorithm: algorithm,
                handicap: handicap
            };

            try {
                const response = await fetch('/api/solve_parking/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: JSON.stringify(data)
                });

                const result = await response.json();
                if (result.error) {
                    alert(result.error);
                    return;
                }

                path = result.path;
                animateSolution(result.path);

            } catch (error) {
                console.error('Error:', error);
            }
        }

        function animateSolution(newPath) {
            if (!newPath || newPath.length === 0) {
                alert("No available spot found!");
                return;
            }

            // Animate the car moving along the path
            let progress = 0;
            const speed = 0.2;

            function step() {
                if (progress >= newPath.length - 1) {
                    path = newPath; // Keep path visible
                    draw();
                    return;
                }

                progress += speed;

                // Interpolate car position
                const idx = Math.floor(progress);
                const t = progress - idx;
                const p1 = newPath[idx];
                const p2 = newPath[idx + 1];

                const carX = p1[0] + (p2[0] - p1[0]) * t;
                const carY = p1[1] + (p2[1] - p1[1]) * t;

                draw(); // Draw base

                // Draw moving car
                drawCar(carX * cellSize, carY * cellSize, '#FFD700', true);

                requestAnimationFrame(step);
            }
            step();
        }
    </script>
</body>

</html>