<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Garbage Truck Routing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #001E2B 0%, #003d5c 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .simulator-container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .header h2 {
            font-size: 2rem;
            color: #00ED64;
            margin-bottom: 0.5rem;
        }

        .header p {
            color: #8BA8B8;
        }

        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 237, 100, 0.3);
        }

        select {
            padding: 8px 12px;
            border-radius: 6px;
            border: 2px solid #00ED64;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 14px;
        }

        .legend {
            display: flex;
            gap: 2rem;
            margin-bottom: 1rem;
            color: #8BA8B8;
            font-size: 0.9rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-box {
            width: 12px;
            height: 12px;
        }

        #stats-panel {
            background: rgba(0, 0, 0, 0.4);
            padding: 1.5rem;
            border-radius: 12px;
            margin-bottom: 1.5rem;
            border: 2px solid #00ED64;
        }

        #stats-panel h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            color: #00ED64;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1.5rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #8BA8B8;
            margin-bottom: 0.5rem;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: white;
        }

        .canvas-area {
            width: 100%;
            height: 600px;
            background: #001419;
            border-radius: 12px;
            overflow: hidden;
            border: 3px solid #00ED64;
            box-shadow: 0 10px 40px rgba(0, 237, 100, 0.2);
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <div class="simulator-container">
        <div class="header">
            <h2>üöõ Advanced Garbage Truck Routing</h2>
            <p>Procedural city generation with traffic, one-way streets, and smart multi-truck routing</p>
        </div>

        <div class="controls">
            <div style="display: flex; gap: 1rem; align-items: center;">
                <label style="color: white;">Time of Day:</label>
                <select id="time-of-day">
                    <option value="morning">Morning (High Traffic)</option>
                    <option value="afternoon">Afternoon (Med Traffic)</option>
                    <option value="night">Night (Low Traffic)</option>
                </select>
            </div>

            <button class="btn" onclick="generateCity()" style="background-color: #00ED64; color: black;">
                üèôÔ∏è Generate New City
            </button>
            <button class="btn" onclick="solveRoute()" style="background-color: #00C152; color: white;">
                üó∫Ô∏è Plan Route
            </button>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-box" style="background: #333;"></div>
                <span>Road</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #00ED64;"></div>
                <span>Building</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #00C152; border-radius: 50%;"></div>
                <span>Garbage Bin</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #FFD700;"></div>
                <span>Depot</span>
            </div>
        </div>

        <div id="stats-panel" style="display: none;">
            <h3>üìä Simulation Results</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-label">Trucks Deployed</div>
                    <div class="stat-value" id="stat-trucks">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Garbage</div>
                    <div class="stat-value" id="stat-garbage">0 kg</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Est. Time</div>
                    <div class="stat-value" id="stat-time">0 min</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Algorithm</div>
                    <div class="stat-value" id="stat-algo" style="font-size: 1.2rem;">-</div>
                </div>
            </div>
        </div>

        <div class="canvas-area" id="canvas-container">
            <canvas id="simCanvas"></canvas>
        </div>
    </div>

    <script>
        /* ----------------------- CANVAS + GLOBALS ----------------------- */
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        let cellSize = 20;
        let cols, rows;
        let grid = [];
        let bins = [];
        let oneWays = [];
        let startNode = null;
        let staticPaths = [];  // Stored colored truck paths
        let isAnimating = false;

        const truckColors = ['#FF4444', '#4477FF', '#FFFF44', '#FF44FF', '#44FFFF', '#FF8844'];

        /* ----------------------- INITIALIZATION ----------------------- */
        setTimeout(() => {
            resizeCanvas();
            generateCity();
        }, 100);

        window.addEventListener('resize', () => {
            resizeCanvas();
            draw();
        });

        function resizeCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            cols = Math.floor(canvas.width / cellSize);
            rows = Math.floor(canvas.height / cellSize);
        }

        /* ----------------------- CITY GENERATION (MOCK) ----------------------- */
        function generateCity() {
            // Reset
            staticPaths = [];
            bins = [];
            oneWays = [];
            isAnimating = false;

            // Generate grid
            grid = [];
            for (let x = 0; x < cols; x++) {
                grid[x] = [];
                for (let y = 0; y < rows; y++) {
                    // Create a simple road network
                    if (x % 4 === 0 || y % 4 === 0) {
                        grid[x][y] = 1; // Road
                    } else {
                        grid[x][y] = 2; // Building
                    }
                }
            }

            // Add some random bins on roads
            for (let i = 0; i < 15; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * cols);
                    y = Math.floor(Math.random() * rows);
                } while (grid[x][y] !== 1 || (x === 0 && y === 0));

                bins.push({
                    x: x,
                    y: y,
                    level: Math.floor(Math.random() * 80) + 20
                });
            }

            // Add some one-way streets
            for (let i = 0; i < 10; i++) {
                let x = Math.floor(Math.random() * cols);
                let y = Math.floor(Math.random() * rows);
                if (grid[x][y] === 1) {
                    oneWays.push({
                        x: x,
                        y: y,
                        dx: Math.random() > 0.5 ? 1 : 0,
                        dy: Math.random() > 0.5 ? 1 : 0
                    });
                }
            }

            // Set depot at first road cell
            startNode = { x: 0, y: 0 };
            for (let x = 0; x < cols; x++) {
                for (let y = 0; y < rows; y++) {
                    if (grid[x][y] === 1) {
                        startNode = { x, y };
                        break;
                    }
                }
                if (startNode.x !== 0 || startNode.y !== 0) break;
            }

            document.getElementById('stats-panel').style.display = 'none';
            draw();
        }

        /* ----------------------- DRAW FUNCTION ----------------------- */
        function draw(truckPositions = []) {
            if (!grid.length) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const timeOfDay = document.getElementById('time-of-day').value;
            const roadColor = timeOfDay === 'morning' ? '#444' :
                timeOfDay === 'afternoon' ? '#383838' : '#333';

            /* Draw terrain */
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const val = grid[i][j];
                    ctx.fillStyle = val === 0 ? '#001E2B' :
                        val === 1 ? roadColor :
                            '#00ED64';

                    ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);

                    // One-way arrows
                    if (val === 1) {
                        const ow = oneWays.find(o => o.x === i && o.y === j);
                        if (ow) {
                            ctx.fillStyle = 'rgba(255,255,255,0.3)';
                            ctx.beginPath();
                            const cx = i * cellSize + cellSize / 2;
                            const cy = j * cellSize + cellSize / 2;
                            const s = cellSize / 4;

                            if (ow.dx === 1) {
                                ctx.moveTo(cx - s, cy - s);
                                ctx.lineTo(cx + s, cy);
                                ctx.lineTo(cx - s, cy + s);
                            } else if (ow.dx === -1) {
                                ctx.moveTo(cx + s, cy - s);
                                ctx.lineTo(cx - s, cy);
                                ctx.lineTo(cx + s, cy + s);
                            } else if (ow.dy === 1) {
                                ctx.moveTo(cx - s, cy - s);
                                ctx.lineTo(cx, cy + s);
                                ctx.lineTo(cx + s, cy - s);
                            } else if (ow.dy === -1) {
                                ctx.moveTo(cx - s, cy + s);
                                ctx.lineTo(cx, cy - s);
                                ctx.lineTo(cx + s, cy + s);
                            }

                            ctx.fill();
                        }
                    }
                }
            }

            /* Draw bins */
            bins.forEach(bin => {
                if (!bin.level) return;
                const alpha = 0.3 + (bin.level / 100) * 0.7;
                ctx.fillStyle = `rgba(0,193,82,${alpha})`;
                ctx.beginPath();
                ctx.arc(
                    bin.x * cellSize + cellSize / 2,
                    bin.y * cellSize + cellSize / 2,
                    cellSize / 3,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                ctx.fillStyle = 'white';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    bin.level,
                    bin.x * cellSize + cellSize / 2,
                    bin.y * cellSize + cellSize / 2
                );
            });

            /* Draw depot */
            if (startNode) {
                const dx = startNode.x * cellSize;
                const dy = startNode.y * cellSize;

                ctx.fillStyle = '#FFD700';
                ctx.fillRect(dx, dy, cellSize, cellSize);

                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.strokeRect(dx + 1, dy + 1, cellSize - 2, cellSize - 2);

                ctx.fillStyle = 'black';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("D", dx + cellSize / 2, dy + cellSize / 2);
            }

            /* Draw permanent truck paths (ALWAYS VISIBLE) */
            staticPaths.forEach((path, i) => {
                if (path.length < 2) return;

                ctx.beginPath();
                ctx.strokeStyle = truckColors[i % truckColors.length];
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalAlpha = 0.7;

                ctx.moveTo(
                    path[0][0] * cellSize + cellSize / 2,
                    path[0][1] * cellSize + cellSize / 2
                );

                for (let k = 1; k < path.length; k++) {
                    ctx.lineTo(
                        path[k][0] * cellSize + cellSize / 2,
                        path[k][1] * cellSize + cellSize / 2
                    );
                }

                ctx.stroke();
                ctx.globalAlpha = 1;
            });

            /* Draw moving trucks (during animation) */
            truckPositions.forEach((pos, i) => {
                ctx.fillStyle = truckColors[i % truckColors.length];
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;

                const cx = pos.x * cellSize + cellSize / 2;
                const cy = pos.y * cellSize + cellSize / 2;

                ctx.beginPath();
                ctx.rect(cx - 8, cy - 8, 16, 16);
                ctx.fill();
                ctx.stroke();

                // Add truck label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`T${i + 1}`, cx, cy);
            });
        }

        /* ----------------------- A* PATHFINDING ----------------------- */
        function findPath(start, goal) {
            const openSet = [start];
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();

            const key = (node) => `${node.x},${node.y}`;
            gScore.set(key(start), 0);
            fScore.set(key(start), heuristic(start, goal));

            while (openSet.length > 0) {
                // Find node with lowest fScore
                let current = openSet.reduce((min, node) =>
                    fScore.get(key(node)) < fScore.get(key(min)) ? node : min
                );

                if (current.x === goal.x && current.y === goal.y) {
                    return reconstructPath(cameFrom, current);
                }

                openSet.splice(openSet.indexOf(current), 1);

                // Check neighbors (only roads)
                const neighbors = getNeighbors(current);
                for (const neighbor of neighbors) {
                    const tentativeGScore = gScore.get(key(current)) + 1;
                    const neighborKey = key(neighbor);

                    if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {
                        cameFrom.set(neighborKey, current);
                        gScore.set(neighborKey, tentativeGScore);
                        fScore.set(neighborKey, tentativeGScore + heuristic(neighbor, goal));

                        if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }

            return []; // No path found
        }

        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function getNeighbors(node) {
            const neighbors = [];
            const directions = [
                { dx: 0, dy: -1 }, // Up
                { dx: 1, dy: 0 },  // Right
                { dx: 0, dy: 1 },  // Down
                { dx: -1, dy: 0 }  // Left
            ];

            for (const dir of directions) {
                const nx = node.x + dir.dx;
                const ny = node.y + dir.dy;

                if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && grid[nx][ny] === 1) {
                    neighbors.push({ x: nx, y: ny });
                }
            }

            return neighbors;
        }

        function reconstructPath(cameFrom, current) {
            const path = [[current.x, current.y]];
            const key = (node) => `${node.x},${node.y}`;

            while (cameFrom.has(key(current))) {
                current = cameFrom.get(key(current));
                path.unshift([current.x, current.y]);
            }

            return path;
        }

        /* ----------------------- K-MEANS CLUSTERING FOR SMART ASSIGNMENT ----------------------- */
        function kMeansClustering(points, k, maxIterations = 50) {
            if (points.length === 0) return [];
            if (k >= points.length) k = points.length;

            // Initialize centroids randomly
            let centroids = [];
            const used = new Set();
            while (centroids.length < k) {
                const idx = Math.floor(Math.random() * points.length);
                if (!used.has(idx)) {
                    centroids.push({ x: points[idx].x, y: points[idx].y });
                    used.add(idx);
                }
            }

            let clusters = [];
            for (let iter = 0; iter < maxIterations; iter++) {
                // Assign points to nearest centroid
                clusters = Array.from({ length: k }, () => []);

                for (const point of points) {
                    let minDist = Infinity;
                    let closestCluster = 0;

                    for (let i = 0; i < centroids.length; i++) {
                        const dist = Math.sqrt(
                            Math.pow(point.x - centroids[i].x, 2) +
                            Math.pow(point.y - centroids[i].y, 2)
                        );
                        if (dist < minDist) {
                            minDist = dist;
                            closestCluster = i;
                        }
                    }

                    clusters[closestCluster].push(point);
                }

                // Recalculate centroids
                let changed = false;
                for (let i = 0; i < k; i++) {
                    if (clusters[i].length === 0) continue;

                    const newX = clusters[i].reduce((sum, p) => sum + p.x, 0) / clusters[i].length;
                    const newY = clusters[i].reduce((sum, p) => sum + p.y, 0) / clusters[i].length;

                    if (Math.abs(newX - centroids[i].x) > 0.1 || Math.abs(newY - centroids[i].y) > 0.1) {
                        changed = true;
                    }

                    centroids[i] = { x: newX, y: newY };
                }

                if (!changed) break;
            }

            return clusters.filter(c => c.length > 0);
        }

        /* ----------------------- NEAREST NEIGHBOR TSP ----------------------- */
        function nearestNeighborTSP(bins, start) {
            if (bins.length === 0) return [];

            const unvisited = [...bins];
            const route = [];
            let current = start;

            while (unvisited.length > 0) {
                let nearestIdx = 0;
                let minDist = Infinity;

                for (let i = 0; i < unvisited.length; i++) {
                    const dist = Math.sqrt(
                        Math.pow(current.x - unvisited[i].x, 2) +
                        Math.pow(current.y - unvisited[i].y, 2)
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        nearestIdx = i;
                    }
                }

                route.push(unvisited[nearestIdx]);
                current = unvisited[nearestIdx];
                unvisited.splice(nearestIdx, 1);
            }

            return route;
        }

        /* ----------------------- SOLVE ROUTES WITH SMART ASSIGNMENT ----------------------- */
        function solveRoute() {
            if (!startNode) return alert("No Depot Found!");
            if (isAnimating) return alert("Animation in progress!");
            if (bins.length === 0) return alert("No bins to collect!");

            // Determine optimal number of trucks based on workload
            const avgGarbagePerBin = bins.reduce((sum, b) => sum + b.level, 0) / bins.length;
            const truckCapacity = 500; // kg
            const minTrucks = Math.ceil(bins.reduce((sum, b) => sum + b.level, 0) / truckCapacity);
            const maxTrucks = Math.min(6, Math.ceil(bins.length / 3));
            const numTrucks = Math.max(minTrucks, Math.min(maxTrucks, Math.ceil(bins.length / 5)));

            // Cluster bins geographically using K-means
            const clusters = kMeansClustering(bins, numTrucks);

            // Balance load across trucks
            clusters.sort((a, b) => {
                const loadA = a.reduce((sum, bin) => sum + bin.level, 0);
                const loadB = b.reduce((sum, bin) => sum + bin.level, 0);
                return loadB - loadA;
            });

            // Redistribute if imbalance is too high
            while (clusters.length > 1) {
                const loads = clusters.map(c => c.reduce((sum, b) => sum + b.level, 0));
                const maxLoad = Math.max(...loads);
                const minLoad = Math.min(...loads);

                if (maxLoad - minLoad < 150) break; // Acceptable imbalance

                const maxIdx = loads.indexOf(maxLoad);
                const minIdx = loads.indexOf(minLoad);

                // Move one bin from heaviest to lightest
                if (clusters[maxIdx].length > 1) {
                    const bin = clusters[maxIdx].pop();
                    clusters[minIdx].push(bin);
                } else {
                    break;
                }
            }

            const paths = [];
            let totalDistance = 0;

            for (let t = 0; t < clusters.length; t++) {
                const clusterBins = clusters[t];
                const fullPath = [];

                // Optimize route within cluster using Nearest Neighbor TSP
                const orderedBins = nearestNeighborTSP(clusterBins, startNode);

                let currentPos = startNode;

                // Visit each bin in optimized order
                for (const bin of orderedBins) {
                    const binPos = { x: bin.x, y: bin.y };
                    const segment = findPath(currentPos, binPos);

                    if (segment.length > 0) {
                        totalDistance += segment.length;
                        if (fullPath.length > 0 &&
                            fullPath[fullPath.length - 1][0] === segment[0][0] &&
                            fullPath[fullPath.length - 1][1] === segment[0][1]) {
                            fullPath.push(...segment.slice(1));
                        } else {
                            fullPath.push(...segment);
                        }
                    }

                    currentPos = binPos;
                }

                // Return to depot
                const returnPath = findPath(currentPos, startNode);
                if (returnPath.length > 0) {
                    totalDistance += returnPath.length;
                    if (fullPath.length > 0 &&
                        fullPath[fullPath.length - 1][0] === returnPath[0][0] &&
                        fullPath[fullPath.length - 1][1] === returnPath[0][1]) {
                        fullPath.push(...returnPath.slice(1));
                    } else {
                        fullPath.push(...returnPath);
                    }
                }

                paths.push(fullPath);
            }

            // Store paths permanently
            staticPaths = paths;

            // Calculate stats
            const totalGarbage = bins.reduce((sum, bin) => sum + bin.level, 0);
            const timeMultiplier = document.getElementById('time-of-day').value === 'morning' ? 1.5 :
                document.getElementById('time-of-day').value === 'afternoon' ? 1.2 : 1.0;
            const estimatedTime = Math.round(bins.length * 2 * timeMultiplier);

            // Update stats panel
            document.getElementById('stats-panel').style.display = 'block';
            document.getElementById('stat-trucks').textContent = numTrucks;
            document.getElementById('stat-garbage').textContent = totalGarbage + ' kg';
            document.getElementById('stat-time').textContent = estimatedTime + ' min';
            document.getElementById('stat-algo').textContent = 'Balanced Load';

            // Start animation
            animateSolution(paths);
        }

        /* ----------------------- ANIMATION ----------------------- */
        function animateSolution(paths) {
            if (!paths || paths.length === 0) return;

            isAnimating = true;
            let maxSteps = Math.max(...paths.map(p => p.length));
            let progress = 0;
            const speed = 0.08; // Slower for better visibility

            function step() {
                if (progress >= maxSteps - 1) {
                    isAnimating = false;
                    draw(); // Final draw with paths visible
                    return;
                }

                progress += speed;

                const truckPositions = paths.map(path => {
                    const idx = Math.min(Math.floor(progress), path.length - 1);
                    const nextIdx = Math.min(idx + 1, path.length - 1);
                    const t = progress - idx;

                    const p1 = path[idx];
                    const p2 = path[nextIdx];

                    return {
                        x: p1[0] + (p2[0] - p1[0]) * t,
                        y: p1[1] + (p2[1] - p1[1]) * t
                    };
                });

                draw(truckPositions);
                requestAnimationFrame(step);
            }

            step();
        }
    </script>
</body>

</html>