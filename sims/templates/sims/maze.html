{% extends 'sims/base.html' %}

{% block title %}Maze Solver - AI Simulators{% endblock %}

{% block content %}
<div class="simulator-container">
    <div class="header">
        <h2>Maze Solver</h2>
        <p>Draw walls, set start/end points, and watch AI algorithms find the path.</p>
    </div>

    <div class="controls">
        <select id="algorithm">
            <option value="bfs">Breadth-First Search (BFS)</option>
            <option value="dfs">Depth-First Search (DFS)</option>
            <option value="astar">A* Search</option>
            <option value="greedy">Greedy Best-First Search</option>
        </select>

        <button class="btn" onclick="setTool('wall')">Draw Walls</button>
        <button class="btn" onclick="setTool('start')">Set Start</button>
        <button class="btn" onclick="setTool('end')">Set End</button>
        <button class="btn" onclick="setTool('eraser')">Eraser</button>
        <button class="btn" onclick="clearMaze()" style="background-color: #ff4444; color: white;">Clear</button>
        <button class="btn" onclick="solveMaze()"
            style="background-color: var(--primary-green); color: black;">Solve</button>
    </div>

    <div class="canvas-area" id="canvas-container">
        <canvas id="mazeCanvas"></canvas>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    const canvas = document.getElementById('mazeCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');

    let cellSize = 20;
    let cols, rows;
    let grid = [];
    let startNode = null;
    let endNode = null;
    let currentTool = 'wall';
    let isDrawing = false;

    // Resize canvas
    function resizeCanvas() {
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        cols = Math.floor(canvas.width / cellSize);
        rows = Math.floor(canvas.height / cellSize);
        initGrid();
        draw();
    }

    window.addEventListener('resize', resizeCanvas);

    function initGrid() {
        grid = new Array(cols).fill(0).map(() => new Array(rows).fill(0));
        // 0: empty, 1: wall
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw grid lines (optional, maybe faint)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        for (let i = 0; i <= cols; i++) {
            ctx.beginPath();
            ctx.moveTo(i * cellSize, 0);
            ctx.lineTo(i * cellSize, rows * cellSize);
            ctx.stroke();
        }
        for (let j = 0; j <= rows; j++) {
            ctx.beginPath();
            ctx.moveTo(0, j * cellSize);
            ctx.lineTo(cols * cellSize, j * cellSize);
            ctx.stroke();
        }

        // Draw walls
        ctx.fillStyle = '#00ED64';
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                if (grid[i][j] === 1) {
                    ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);
                }
            }
        }

        // Draw start and end
        if (startNode) {
            ctx.fillStyle = '#00C152'; // Bright Green
            ctx.beginPath();
            ctx.arc(startNode.x * cellSize + cellSize / 2, startNode.y * cellSize + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
            ctx.fill();
        }
        if (endNode) {
            ctx.fillStyle = '#FF4444'; // Red
            ctx.beginPath();
            ctx.arc(endNode.x * cellSize + cellSize / 2, endNode.y * cellSize + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: Math.floor((evt.clientX - rect.left) / cellSize),
            y: Math.floor((evt.clientY - rect.top) / cellSize)
        };
    }

    function setTool(tool) {
        currentTool = tool;
    }

    function clearMaze() {
        grid = grid.map(col => col.map(() => 0));
        startNode = null;
        endNode = null;
        draw();
    }

    canvas.addEventListener('mousedown', (e) => {
        isDrawing = true;
        handleInput(e);
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isDrawing) handleInput(e);
    });

    canvas.addEventListener('mouseup', () => isDrawing = false);
    canvas.addEventListener('mouseleave', () => isDrawing = false);

    function handleInput(e) {
        const pos = getMousePos(e);
        if (pos.x < 0 || pos.x >= cols || pos.y < 0 || pos.y >= rows) return;

        if (currentTool === 'wall') {
            grid[pos.x][pos.y] = 1;
        } else if (currentTool === 'eraser') {
            grid[pos.x][pos.y] = 0;
            if (startNode && startNode.x === pos.x && startNode.y === pos.y) startNode = null;
            if (endNode && endNode.x === pos.x && endNode.y === pos.y) endNode = null;
        } else if (currentTool === 'start') {
            startNode = pos;
            grid[pos.x][pos.y] = 0; // Clear wall if any
        } else if (currentTool === 'end') {
            endNode = pos;
            grid[pos.x][pos.y] = 0; // Clear wall if any
        }
        draw();
    }

    async function solveMaze() {
        if (!startNode || !endNode) {
            alert('Please set both Start and End points.');
            return;
        }

        const algorithm = document.getElementById('algorithm').value;
        const data = {
            grid: grid,
            start: startNode,
            end: endNode,
            algorithm: algorithm
        };

        try {
            const response = await fetch('/api/solve_maze/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': '{{ csrf_token }}'
                },
                body: JSON.stringify(data)
            });

            const result = await response.json();
            if (result.error) {
                alert(result.error);
                return;
            }

            animateSolution(result.visited, result.path);

        } catch (error) {
            console.error('Error:', error);
        }
    }

    function animateSolution(visited, path) {
        let i = 0;

        function animateVisited() {
            if (i >= visited.length) {
                animatePath();
                return;
            }
            const node = visited[i];
            if (!(node[0] === startNode.x && node[1] === startNode.y) &&
                !(node[0] === endNode.x && node[1] === endNode.y)) {
                ctx.fillStyle = 'rgba(0, 237, 100, 0.3)';
                ctx.fillRect(node[0] * cellSize, node[1] * cellSize, cellSize, cellSize);
            }
            i++;
            requestAnimationFrame(animateVisited);
        }

        function animatePath() {
            ctx.beginPath();
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 3;
            ctx.moveTo(startNode.x * cellSize + cellSize / 2, startNode.y * cellSize + cellSize / 2);

            let j = 0;
            function step() {
                if (j >= path.length) return;
                const node = path[j];
                ctx.lineTo(node[0] * cellSize + cellSize / 2, node[1] * cellSize + cellSize / 2);
                ctx.stroke();
                j++;
                requestAnimationFrame(step);
            }
            step();
        }

        animateVisited();
    }

    // Initial setup
    setTimeout(resizeCanvas, 100);
</script>
{% endblock %}